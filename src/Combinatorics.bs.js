// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function permutations(s, n) {
  if (n !== 1) {
    return Belt_List.reduce(s, /* [] */0, (function (a, e) {
                  return Pervasives.$at(a, Belt_List.map(permutations(s, n - 1 | 0), (function (p) {
                                    return Pervasives.$at(p, /* :: */[
                                                e,
                                                /* [] */0
                                              ]);
                                  })));
                }));
  } else {
    return Belt_List.map(s, (function (e) {
                  return /* :: */[
                          e,
                          /* [] */0
                        ];
                }));
  }
}

function otherElements(set, subset) {
  return Belt_List.keep(set, (function (e) {
                return !Belt_List.has(subset, e, Caml_obj.caml_equal);
              }));
}

function combinedWith(accum, others, set, n) {
  console.log("\n\nframe");
  console.log("accum");
  console.log(accum);
  console.log("others");
  console.log(others);
  if (Belt_List.length(accum) === n) {
    return accum;
  } else if (Belt_List.length(others) === 1) {
    console.log("Recursion ended");
    var res = Belt_List.concat(others, accum);
    console.log(Belt_List.length(res));
    return res;
  } else {
    return Belt_List.reduce(others, /* [] */0, (function (a, o) {
                  var combined = /* :: */[
                    o,
                    accum
                  ];
                  return Belt_List.concat(a, combinedWith(combined, otherElements(set, combined), set, n));
                }));
  }
}

exports.permutations = permutations;
exports.otherElements = otherElements;
exports.combinedWith = combinedWith;
/* No side effect */
